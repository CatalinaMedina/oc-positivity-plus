---
title: "Factors associated with seroprevelance of SARS-CoV2 in Orange County"
output: 
  pdf_document:
    extra_dependencies:
      amsmath 
params:
  reclean_data: FALSE
  first_test_date: "2020-03-01"
  last_test_date: "2020-08-16"
  refit_model1: FALSE
  refit_model2: FALSE
  refit_model3: FALSE
  refit_model4: FALSE
  refit_model5: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      error = FALSE,
                      fig.pos = "H")
```


```{r loading-libraries}
# data-wrangling-function chunk
library(tidyverse)
library(here)
library(lubridate)
library(data.table)
# missing-data-table chunk
library(knitr)
library(kableExtra)
# fit-model1 chunk
library(tictoc)
library(lme4)
library(BRRR)
library(car) # I don't think I need this anymore
library(mgcv)
```


```{r data-wrangling-function}
read_sero <- function(file_path, start_date, end_date){
  # Read in and select data of interest-----------------------------------------

  sero_results_original <- read_csv(
    file_path,
    col_types = cols(
      .default = col_skip(),
      E4 = col_integer(),
      DV_PANEL = col_character(),
      DV_IMPORT_TEST_RESULTresult = col_character(),
      Q1 = col_integer(),
      Q2 = col_integer(),
      Q3 = col_character(),
      Q6r1 = col_integer(),
      Q6r2 = col_integer(),
      Q6r3 = col_integer(),
      Q6r4 = col_integer(),
      Q6r5 = col_integer(),
      Q6r6 = col_integer(),
      Q6r7 = col_integer(),
      Q6r8 = col_integer(),
      Q7 = col_integer()
    ) 
  )
  
  
  sero_results_filtered <- sero_results_original %>% 
    filter(E4 == 1) %>% # Only individuals who had a blood test completed
    filter(DV_PANEL != 7) # Only individuals who are not home recruits
  
  
  # tidy seroprevelance data----------------------------------------------------
  
  sero_results_adjusted <- sero_results_filtered %>% 
    filter(
      DV_IMPORT_TEST_RESULTresult == "Reactive" |
      DV_IMPORT_TEST_RESULTresult == "Non-Reactive"
    ) %>% 
    mutate(covid_pos = factor(
      DV_IMPORT_TEST_RESULTresult,
      levels = c("Non-Reactive", "Reactive"),
      labels = c("no", "yes")
    )) %>% 
    mutate(age_grp = factor(
      Q2,
      levels = 2:15,
      labels = c(
        "18-24",
        "25-29",
        "30-34",
        "35-39",
        "40-44",
        "45-49",
        "50-54",
        "55-59",
        "60-64",
        "65-69",
        "70-74",
        "75-79",
        "80-84",
        "85+"
      )
    )) %>% 
    filter(Q1 == 1 | Q1 == 2) %>% 
    mutate(sex = factor(
      Q1,
      levels = c(2, 1),
      labels = c("female", "male")
    )) %>% 
    mutate(race = factor(
      case_when(
        ((Q6r1 == 1) & (Q6r2 + Q6r3 + Q6r4 + Q6r5 + Q6r6 + Q6r7 + Q6r8 == 0)) ~ "white",
        ((Q6r2 == 2) & (Q6r1 + Q6r3 + Q6r4 + Q6r5 + Q6r6 + Q6r7 + Q6r8 == 0)) ~ "black",
        ((Q6r3 == 3) & (Q6r1 + Q6r2 + Q6r4 + Q6r5 + Q6r6 + Q6r7 + Q6r8 == 0)) ~ "hispanic",
        ((Q6r4 == 4) & (Q6r1 + Q6r2 + Q6r3 + Q6r5 + Q6r6 + Q6r7 + Q6r8 == 0)) ~ "native",
        ((Q6r5 == 5) & (Q6r1 + Q6r2 + Q6r3 + Q6r4 + Q6r6 + Q6r7 + Q6r8 == 0)) ~ "asian",
        ((Q6r6 == 6) & (Q6r1 + Q6r2 + Q6r3 + Q6r4 + Q6r5 + Q6r7 + Q6r8 == 0)) ~ "islander",
        TRUE ~ "unknown"
      ),
      levels = c("white", "black", "hispanic", "native", "asian", "islander", "unknown")
    )) %>% 
    select(
      zip = Q3,
      covid_pos,
      age_grp,
      sex,
      race
    )

  
  # Add zip code level data and merge with pcr results--------------------------
  zip_area_oc <- read_csv(
    here("data/zip-code-data", "zip-area2.csv"),
    col_types = cols(
      .default = col_skip(),
      NAME = col_character(),
      Zip = col_character(),
      AreaKm = col_double()
      )
    ) %>%
    select(name = NAME, zip = Zip, area_km = AreaKm)
  
  zip_pop_oc <- read_csv(
    here("data/zip-code-data", "zip-pop.csv"),
    col_types = cols(
      .default = col_skip(),
      Zip = col_character(),
      Population = col_integer()
      )
    ) %>%
    drop_na() %>%
    mutate(population = Population / 1000) %>%
    select(zip = Zip, population)
  
  zip_data_merged <- merge(x = zip_area_oc, y = zip_pop_oc, by = "zip")
  zip_data_merged$pop_density <- zip_data_merged$population / zip_data_merged$area_km
  
  zip_income_oc <- read_csv(
    here("data/zip-code-data", "income-by-zip2.csv"),
    col_types = cols(
      .default = col_skip(),
      Zip = col_character(),
      IncomeMed = col_integer(),
      IncPeriodofMeas = col_character()
      )
    ) %>%
    mutate(med_income = IncomeMed / 10000) %>%
    filter(IncPeriodofMeas == "2014-2018") %>%
    select(zip = Zip, med_income)
  
  zip_data_merged <- merge(x = zip_data_merged, y = zip_income_oc, by = "zip")

  zip_education_oc <- read_csv(
    here("data/zip-code-data", "education-by-zip.csv"),
    col_types = cols(
      .default = col_skip(),
      Zip = col_character(),
      PercentBach = col_double()
      )
    ) %>%
    select(zip = Zip, percent_bachelors = PercentBach)
  
  zip_data_merged <- merge(x = zip_data_merged, y = zip_education_oc, by = "zip")

  zip_insurance_oc <- read_csv(
    here("data/zip-code-data", "insurance-by-zip.csv"),
    col_types = cols(
      .default = col_skip(),
      Zip = col_character(),
      PercentInsured = col_double()
      )
    ) %>%                           
    select(zip = Zip, percent_insured = PercentInsured)
  
  zip_data_merged <- merge(x = zip_data_merged, y = zip_insurance_oc, by = "zip")
  
  
  # Scale zip code level variables
  zip_data_merged$adj_pop_density <- scale(
    zip_data_merged$pop_density , 
    center = TRUE, 
    scale = TRUE
    )
  
  zip_data_merged$adj_med_income <- scale(
    zip_data_merged$med_income, 
    center = TRUE, 
    scale = TRUE
    )
  
  zip_data_merged$adj_perc_bach <- scale(
    zip_data_merged$percent_bachelors,
    center = TRUE,
    scale = TRUE
    )
  
  zip_data_merged$adj_perc_bach_quar <- with(
    zip_data_merged,
    cut(adj_perc_bach,
        breaks = quantile(adj_perc_bach, 
        probs = seq(0, 1, by = 0.25)),
        include.lowest = TRUE,
        labels = c("Q1", "Q2", "Q3", "Q4"))
    )
  
  zip_data_merged$adj_perc_insured <- scale(
    zip_data_merged$percent_insured,
    center = TRUE,
    scale = TRUE
    )
  
  zip_data_merged$adj_perc_insured_quar <- with(
    zip_data_merged,
    cut(
      adj_perc_insured,
      breaks = quantile(adj_perc_insured, probs = seq(0, 1, by = 0.25)),
      include.lowest = TRUE,
      labels = c("Q1", "Q2", "Q3", "Q4")
      )
    )
  
  # We don't have an area estimate for 92678 so we replace with 92679
  sero_results_adjusted$old_zip <- sero_results_adjusted$zip
  sero_results_adjusted$zip[sero_results_adjusted$old_zip == "92678"] <- "92679"
  sero_results_merged <- merge(x = sero_results_adjusted, y = zip_data_merged, by = "zip")
  sero_results_merged$old_zip <- factor(sero_results_merged$old_zip)
  sero_results_merged$zip <- factor(sero_results_merged$zip)
  
  
  # Count missing values--------------------------------------------------------
  missing_vec <- c(
    nrow(sero_results_filtered) , # number of observations with test date between start date and end date
    nrow(sero_results_filtered) - nrow(sero_results_adjusted),  # number of NA for age, sex and zip
    nrow(sero_results_adjusted) - nrow(sero_results_merged) # number of invalid or non Orange County zip codes
  )
  names(missing_vec) <- c(
    "full_num_data_cases", 
    "num_na_cases_removed", 
    "num_bad_zip_cases_removed"
  )
  
  
  list(
    "sero_results_merged" = sero_results_merged, 
    "zip_data_merged" = zip_data_merged, 
    "missing" = missing_vec
  )
}
```


```{r load-clean-data}
if (params$reclean_data) {
  all_sero_and_zip <- read_sero(
    file_path = here("data/seroprevelance-data", "oc-seroprevelence-data-2020-08-01.csv"),
    start_date = params$first_test_date,
    end_date = params$last_test_date
  )
  
  save(all_sero_and_zip, file = here("data/seroprevelance-data", "cleaned_process_sero_data.Rdata"))
} else {
  load(file = here("data/seroprevelance-data", "cleaned_process_sero_data.Rdata"))
}

all_sero <- data.frame(all_sero_and_zip[["sero_results_merged"]])
all_zip <- data.frame(all_sero_and_zip[["zip_data_merged"]])
sero_missing <- all_sero_and_zip[["missing"]]
```


```{r missing-data-table}
usable_counts <- c(
  sero_missing[1],
  sero_missing[1] - sero_missing[2],
  sero_missing[1] - sum(sero_missing[2:3])
)

tab_obs <- data.frame(
  c(NA, sero_missing[2:3]), 
  usable_counts
)
rownames(tab_obs) <- c(
  "Unmodified",
  "Missing or Inconclusive[note]",
  "Invalid Zip Code"
)

kable(
  tab_obs,
  col.names = c(
    "With Issue", 
    "After Removal"
  ),
  format = "latex",
  caption = paste(
    "Number of sero-positive COVID-19 tests in Orange County from ",
      params$first_test_date, " to ", params$last_test_date,
      ". Includes number removed from data by type of issue for this analysis.",
    sep = "")
  ) %>%
  kable_styling(latex_options = c("HOLD_position")) %>% 
  add_header_above(c(" " = 1, "Number of Tests" = 2), line = TRUE) %>% 
  column_spec(column = 2:3, width = "5.5cm") %>% 
  add_footnote(
    c(
      "Number without conclusive test result or complete demographic information"
      ),
    notation = "symbol",
    threeparttable = TRUE
    )
```


```{r results-functions} 
compute_ci_logistic_glm <- function(model, alpha = 0.05, param_names, include_pvalues = FALSE) {
  #does not include intercept or median income
  model_summary <- summary(model)
  coeffs <- model_summary$coefficients[-1, 1]
  se_robust <- sqrt(diag(sandwich(model)))[-1]
  model_sum <- data.frame("odds" = exp(coeffs),
                          "lower_bound" = exp(coeffs - qnorm(1 - alpha / 2) * se_robust),
                          "upper_bound" = exp(coeffs + qnorm(1 - alpha / 2) * se_robust),
                          "p-value" =  model_summary$coefficients[-1, 4],
                          "param_names" = param_names)
  if(include_pvalues){
    return("model_sum" = model_sum)
  } else {
    return("model_sum" = model_sum[, -4])
  }
}

compute_ci_logistic_glmer <- function(model, alpha = 0.05, param_names, include_pvalues = FALSE) {
  #does not include intercept or median income
  model_summary <- summary(model)
  coeffs <- model_summary$coefficients[-1, 1]
  se <- model_summary$coefficients[-1,2]
  model_sum <- data.frame("odds" = exp(coeffs),
                          "lower_bound" = exp(coeffs - qnorm(1 - alpha / 2) * se),
                          "upper_bound" = exp(coeffs + qnorm(1 - alpha / 2) * se),
                          "p-value" =  model_summary$coefficients[-1, 4],
                          "param_names" = param_names)
  if(include_pvalues){
    return("model_sum" = model_sum)
  } else {
    return("model_sum" = model_sum[, -4])
  }
}

```


For simplicity let  
$O_i$ be the odds of testing positive for COVID-19 in Orange County.  
$\overrightarrow{\beta}_{(1-14)} = (\beta_{\text{Age[18-24]}}, \beta_{\text{Age[25-29]}}, \beta_{\text{Age[30-34]}}, \beta_{\text{Age[35-39]}}, \beta_{\text{Age[40-44]}}, \beta_{\text{Age[45-49]}}, \beta_{\text{Age[50-54]}}, \\ \beta_{\text{Age[55-59]}}, \beta_{\text{Age[60-64]}}, \beta_{\text{Age[65-69]}}, \beta_{\text{Age[70-74]}}, \beta_{\text{Age[75-79]}}, \beta_{\text{Age[80-84]}}, \beta_{\text{Age[85+]}})$  
$\overrightarrow{\beta}_{(16-21)} = (\beta_{\text{Asian}}, \beta_{\text{Black}}, \beta_{\text{Hispanic}}, \beta_{\text{NativeAmerican}}, \beta_{\text{PacificIslander}}, \beta_{\text{Unknown}})$  
$\overrightarrow{\beta}_{(22-24)} = (\beta_{\text{EducationQ2}}, \beta_{\text{EducationQ3}}, \beta_{\text{EducationQ4}})$  
$\overrightarrow{\beta}_{(25-27)} = (\beta_{\text{InsuredQ2}}, \beta_{\text{InsuredQ3}}, \beta_{\text{InsuredQ4}})$


Model 0:
\begin{equation}
\label{eq:Model0}
	\begin{split}
		\log(O_i) &= \beta_0 + \overrightarrow{\beta}_{(1-14)}\overrightarrow{\text{Age Groups}}_i + \beta_{Sex}\text{Sex}_i + \overrightarrow{\beta}_{(16-21)}\overrightarrow{\text{Race}}_i\\
		&+ \overrightarrow{\beta}_{(22-24)}\overrightarrow{\text{\% with College Degree Quartile}}_i + \overrightarrow{\beta}_{(25-27)}\overrightarrow{\text{\% with Insurance Quartile}}_i \\
		&+ \beta_{\text{Population Density}}\text{Population Density}_i + \beta_{\text{Median Income}}\text{Median Income}_i,
	\end{split}
\end{equation}
without a random intercept for zip code.


```{r fit-model0}
if (params$refit_model0) {
  fit0 <- glm(
    formula = covid_pos ~ age_grp + sex + race + 
              adj_perc_bach_quar + adj_perc_insured_quar +
              adj_pop_density + adj_med_income,
    family = binomial, 
    data = all_sero
    )

  save(fit0, file = here("analysis/testing-seropositive-regression-results", "fit0.Rdata"))
} else {
  load(file = here("analysis/testing-seropositive-regression-results", "fit0.Rdata"))
}
```


Model 1:
\begin{equation}
\label{eq:Model1}
	\begin{split}
		\log(O_i) &= \beta_0 + \overrightarrow{\beta}_{(1-14)}\overrightarrow{\text{Age Groups}}_i + \beta_{Sex}\text{Sex}_i + \overrightarrow{\beta}_{(16-21)}\overrightarrow{\text{Race}}_i\\
		&+ \overrightarrow{\beta}_{(22-24)}\overrightarrow{\text{\% with College Degree Quartile}}_i + \overrightarrow{\beta}_{(25-27)}\overrightarrow{\text{\% with Insurance Quartile}}_i \\
		&+ \beta_{\text{Population Density}}\text{Population Density}_i + \beta_{\text{Median Income}}\text{Median Income}_i,
	\end{split}
\end{equation}
with a random intercept for zip code.


```{r fit-model1}
if (params$refit_model1) {
  tic()
  fit1a <- glmer(
    formula = covid_pos ~ age_grp + sex + race + 
              adj_perc_bach_quar + adj_perc_insured_quar +
              adj_pop_density + adj_med_income +
              (1 | zip),              
    family = binomial, 
    data = all_sero,
    control = glmerControl(optimizer ="bobyqa", optCtrl = list(maxfun = 2e6))
    )
  toc()

  tic()
  ss <- getME(fit1a, c("theta","fixef"))
  fit1b <- update(
    fit_time_lin1,
    start = ss,
    control = glmerControl(
      optimizer = "bobyqa",
      optCtrl = list(maxfun = 2e6)
    )
  )
  toc()
  fit1 <- fit1b
  skrrrahh("drummaboy")

  save(fit1, file = here("analysis/testing-seropositive-regression-results", "fit1.Rdata"))
} else {
  load(file = here("analysis/testing-seropositive-regression-results", "fit1.Rdata"))
}
```

